"""
This type stub file was generated by pyright.
"""

START_OF_DAY = ...
END_OF_DAY = ...
url_regex = ...
def url(value):
    """Validate a URL.

    :param string value: The URL to validate
    :returns: The URL if valid.
    :raises: ValueError
    """
    ...

class regex:
    """Validate a string based on a regular expression.

    Example::

        parser = reqparse.RequestParser()
        parser.add_argument('example', type=inputs.regex('^[0-9]+$'))

    Input to the ``example`` argument will be rejected if it contains anything
    but numbers.

    :param pattern: The regular expression the input must match
    :type pattern: str
    :param flags: Flags to change expression behavior
    :type flags: int
    """
    def __init__(self, pattern, flags=...) -> None:
        ...
    
    def __call__(self, value):
        ...
    
    def __deepcopy__(self, memo): # -> regex:
        ...
    


def iso8601interval(value, argument=...): # -> tuple[datetime, datetime | Any]:
    """Parses ISO 8601-formatted datetime intervals into tuples of datetimes.

    Accepts both a single date(time) or a full interval using either start/end
    or start/duration notation, with the following behavior:

    - Intervals are defined as inclusive start, exclusive end
    - Single datetimes are translated into the interval spanning the
      largest resolution not specified in the input value, up to the day.
    - The smallest accepted resolution is 1 second.
    - All timezones are accepted as values; returned datetimes are
      localized to UTC. Naive inputs and date inputs will are assumed UTC.

    Examples::

        "2013-01-01" -> datetime(2013, 1, 1), datetime(2013, 1, 2)
        "2013-01-01T12" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)
        "2013-01-01/2013-02-28" -> datetime(2013, 1, 1), datetime(2013, 2, 28)
        "2013-01-01/P3D" -> datetime(2013, 1, 1), datetime(2013, 1, 4)
        "2013-01-01T12:00/PT30M" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)
        "2013-01-01T06:00/2013-01-01T12:00" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)

    :param str value: The ISO8601 date time as a string
    :return: Two UTC datetimes, the start and the end of the specified interval
    :rtype: A tuple (datetime, datetime)
    :raises: ValueError, if the interval is invalid.
    """
    ...

def date(value): # -> datetime:
    """Parse a valid looking date in the format YYYY-mm-dd"""
    ...

def natural(value, argument=...): # -> int:
    """ Restrict input type to the natural numbers (0, 1, 2, 3...) """
    ...

def positive(value, argument=...): # -> int:
    """ Restrict input type to the positive integers (1, 2, 3...) """
    ...

class int_range:
    """ Restrict input to an integer in a range (inclusive) """
    def __init__(self, low, high, argument=...) -> None:
        ...
    
    def __call__(self, value): # -> int:
        ...
    


def boolean(value): # -> bool:
    """Parse the string ``"true"`` or ``"false"`` as a boolean (case
    insensitive). Also accepts ``"1"`` and ``"0"`` as ``True``/``False``
    (respectively). If the input is from the request JSON body, the type is
    already a native python boolean, and will be passed through without
    further parsing.
    """
    ...

def datetime_from_rfc822(datetime_str): # -> datetime:
    """Turns an RFC822 formatted date into a datetime object.

    Example::

        inputs.datetime_from_rfc822("Wed, 02 Oct 2002 08:00:00 EST")

    :param datetime_str: The RFC822-complying string to transform
    :type datetime_str: str
    :return: A datetime
    """
    ...

def datetime_from_iso8601(datetime_str): # -> datetime:
    """Turns an ISO8601 formatted datetime into a datetime object.

    Example::

        inputs.datetime_from_iso8601("2012-01-01T23:30:00+02:00")

    :param datetime_str: The ISO8601-complying string to transform
    :type datetime_str: str
    :return: A datetime
    """
    ...

